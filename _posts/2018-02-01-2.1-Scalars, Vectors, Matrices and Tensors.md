---
bg: "galoped.jpg"
layout: post
mathjax: true
title:  "2.1 - Scalars, vectors, matrices and tensors"
crawlertitle: "2.1 - Scalars, vectors, matrices and tensors"
summary: "Scalars, vectors, matrices and tensors"
date:   2018-02-01 20:09:47 +0700
categories: posts
tags: ['linear-algebra', 'python', 'numpy', 'deep-learning-book']
author: hadrien
jupyter: https://github.com/hadrienj/deepLearningBook-Notes/blob/master/2.1%20Scalars%2C%20Vectors%2C%20Matrices%20and%20Tensors.ipynb
---

Definition of scalars, vectors, matrices and tensors and their basic use with Python-Numpy.

- A scalar is a single number
- A vector is an array of numbers. Graphically, each value can be thought of a different axis.

$
\boldsymbol{x} =\begin{bmatrix}
    x_1 \\\
    x_2 \\\
    \cdots \\\
    x_n
\end{bmatrix}
$

- A matrix is a 2-D array

$
\boldsymbol{A}=
\begin{bmatrix}
A_{1,1} & A_{1,2} & \cdots & A_{1,n} \\\
A_{2,1} & A_{2,2} & \cdots & A_{2,n} \\\
\cdots & \cdots & \cdots & \cdots \\\
A_{m,1} & A_{m,2} & \cdots & A_{m,n}
\end{bmatrix}
$

- A tensor is a $n$-D array with $n>2$

### Example 1.

#### Create a vector

```python
x = np.array([1, 2, 3, 4])
print(x)
```

    [1 2 3 4]


### Example 2.

#### Create a (3x2) matrix (nested brackets)


```python
A = np.array([[1, 2], [3, 4], [5, 6]])
print(A)
```

    [[1 2]
     [3 4]
     [5 6]]


### Shape

The shape of an array gives you the dimension of the array and their length. It the array is 2-D it will give you the number of rows x number of columns. You can it with:


```python
print 'A.shape', A.shape
print("A has %s rows and %s columns" %(A.shape[0], A.shape[1]))
```

    A.shape (3, 2)
    A has 3 rows and 2 columns


# Transpose

The transpose $A^{\text{T}}$ of the matrix A corresponds to the mirrored axes.

$
\boldsymbol{A}=
\begin{bmatrix}
    A_{1,1} & A_{1,2} \\\
    A_{2,1} & A_{2,2} \\\
    A_{3,1} & A_{3,2}
\end{bmatrix}
$

$
\boldsymbol{A}^{\text{T}}=
\begin{bmatrix}
    A_{1,1} & A_{2,1} & A_{3,1} \\\
    A_{1,2} & A_{2,2} & A_{3,2} \\\
\end{bmatrix}
$

The shape ($m \times n$) is inverted and becomes ($n \times m$).

### Example 3.

#### Create a matrix A and transpose it


```python
A = np.array([[1, 2], [3, 4], [5, 6]])
print("A.shape: %s\n%s" %(A.shape, A))

A_t = A.T
print("\nA_t.shape: %s\n%s\n" %(A_t.shape, A_t))

print("The shape of A is %s. The shape of the transpose of A is %s" %(A.shape, A_t.shape))
```

    A.shape: (3, 2)
    [[1 2]
     [3 4]
     [5 6]]

    A_t.shape: (2, 3)
    [[1 3 5]
     [2 4 6]]
    
    The shape of A is (3, 2). The shape of the transpose of A is (2, 3)


# Addition

Matrices can be added if they have the same shape

$
\begin{bmatrix}
    A_{1,1} & A_{1,2} \\\
    A_{2,1} & A_{2,2} \\\
    A_{3,1} & A_{3,2}
\end{bmatrix}+
\begin{bmatrix}
    B_{1,1} & B_{1,2} \\\
    B_{2,1} & B_{2,2} \\\
    B_{3,1} & B_{3,2}
\end{bmatrix}=
\begin{bmatrix}
    A_{1,1} + B_{1,1} & A_{1,2} + B_{1,2} \\\
    A_{2,1} + B_{2,1} & A_{2,2} + B_{2,2} \\\
    A_{3,1} + B_{3,1} & A_{3,2} + B_{3,2}
\end{bmatrix}
$

$
\boldsymbol{A}_ {i,j} + \boldsymbol{B}_ {i,j} = \boldsymbol{C}_ {i,j}
$


```python
A = np.array([[1, 2], [3, 4], [5, 6]])
print("A.shape: %s\n\n%s\n" %(A.shape, A))

B = np.array([[2, 5], [7, 4], [4, 3]])
print("B.shape: %s\n\n%s\n" %(B.shape, B))

# Add matrices A and B
C = A + B
print("C.shape: %s\n\n%s" %(C.shape, C))
```

    A.shape: (3, 2)
    
    [[1 2]
     [3 4]
     [5 6]]
    
    B.shape: (3, 2)
    
    [[2 5]
     [7 4]
     [4 3]]
    
    C.shape: (3, 2)
    
    [[ 3  7]
     [10  8]
     [ 9  9]]


#### The shape of C is the same as the shape of A and B.


```python
print("A: %s\nB: %s\nC: %s" %(A.shape, B.shape, C.shape))
```

    A: (3, 2)
    B: (3, 2)
    C: (3, 2)


It is also possible to add a scalar to a matrix

$
\alpha+ \begin{bmatrix}
    A_{1,1} & A_{1,2} \\\
    A_{2,1} & A_{2,2} \\\
    A_{3,1} & A_{3,2}
\end{bmatrix}=
\begin{bmatrix}
    \alpha + A_{1,1} & \alpha + A_{1,2} \\\
    \alpha + A_{2,1} & \alpha + A_{2,2} \\\
    \alpha + A_{3,1} & \alpha + A_{3,2}
\end{bmatrix}
$


```python
# Add 4 to the matrix A
C = 4*A
print("C.shape: %s\n\n%s" %(C.shape, C))
```

    C.shape: (3, 2)
    
    [[ 4  8]
     [12 16]
     [20 24]]


# Broadcasting

Numpy can handle arrays of different shape. The smaller array will be extended to match the shape of the bigger one. The advantage is that this is done in `C` under the hood (like any vectorized operation in numpy). Actually the simpler example of broadcasting is what we saw before when multiplied a scalar with a matrix. The scalar was converted in an array of same shape to do that.

Here is another generic example:

$
\begin{bmatrix}
    A_{1,1} & A_{1,2} \\\
    A_{2,1} & A_{2,2} \\\
    A_{3,1} & A_{3,2}
\end{bmatrix}+
\begin{bmatrix}
    B_{1,1} \\\
    B_{2,1} \\\
    B_{3,1}
\end{bmatrix}=
\begin{bmatrix}
    A_{1,1} + B_{1,1} & A_{1,2} + B_{1,1} \\\
    A_{2,1} + B_{2,1} & A_{2,2} + B_{2,1} \\\
    A_{3,1} + B_{3,1} & A_{3,2} + B_{3,1}
\end{bmatrix}
$

is equivalent to

$
\begin{bmatrix}
    A_{1,1} & A_{1,2} \\\
    A_{2,1} & A_{2,2} \\\
    A_{3,1} & A_{3,2}
\end{bmatrix}+
\begin{bmatrix}
    B_{1,1} & B_{1,1} \\\
    B_{2,1} & B_{2,1} \\\
    B_{3,1} & B_{3,1}
\end{bmatrix}=
\begin{bmatrix}
    A_{1,1} + B_{1,1} & A_{1,2} + B_{1,1} \\\
    A_{2,1} + B_{2,1} & A_{2,2} + B_{2,1} \\\
    A_{3,1} + B_{3,1} & A_{3,2} + B_{3,1}
\end{bmatrix}
$

where the ($3 \times 1$) matrix is converted to the right shape ($3 \times 2$) by copying the first column. Numpy will do that automatically if the shapes can match.


```python
A = np.array([[1, 2], [3, 4], [5, 6]])
print("A.shape: %s\n\n%s\n" %(A.shape, A))

B = np.array([[2], [4], [6]])
print("B.shape: %s\n\n%s\n" %(B.shape, B))

# Broadcasting
C=A+B
print("C.shape: %s\n\n%s" %(C.shape, C))
```

    A.shape: (3, 2)
    
    [[1 2]
     [3 4]
     [5 6]]
    
    B.shape: (3, 1)
    
    [[2]
     [4]
     [6]]
    
    C.shape: (3, 2)
    
    [[ 3  4]
     [ 7  8]
     [11 12]]


# References

[1] [Broadcasting in Numpy](https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html)
