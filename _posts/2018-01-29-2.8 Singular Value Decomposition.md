---
bg: "tools.jpg"
layout: post
mathjax: true
title:  "Singular Value Decomposition - SVD"
crawlertitle: "Singular Value Decomposition - SVD"
summary: "Deep learning: Singular Value Decomposition - SVD."
date:   2018-01-29 20:09:47 +0700
categories: posts
tags: ['linear-algebra']
author: hadrien
---

```python
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
```


```python
# Plot parameters
sns.set()
# Seven hls color palette
current_palette_7 = sns.color_palette("hls", 7)
sns.set_palette(current_palette_7)

%pylab inline
pylab.rcParams['figure.figsize'] = (4, 4)
plt.rcParams['xtick.major.size'] = 0
plt.rcParams['ytick.major.size'] = 0
# rcParams.keys()
```

    Populating the interactive namespace from numpy and matplotlib



```python
# Avoid inaccurate floating values (for inverse matrices in dot product for instance)
# See https://stackoverflow.com/questions/24537791/numpy-matrix-inversion-rounding-errors
np.set_printoptions(suppress=True)
```

# Singular Value Decomposition

The eigendecomposition can be done only for square matrices. The way to decompose other type of matrices that can't be decomposed with eigendecomposition is to use singular value decomposition. Instead of having the following eigendecomposition equation:

$$
\boldsymbol{A}=\boldsymbol{V}\cdot diag(\boldsymbol{\lambda}) \cdot \boldsymbol{V}^{-1}
$$

We decompose it into 3 matrices:

$$
\boldsymbol{A}=\boldsymbol{UDV}^{\text{T}}
$$

With the following matrix properties:

- $\boldsymbol{U}$ and $\boldsymbol{V}$ being orthogonal matrices ($\boldsymbol{U}^\text{T}=\boldsymbol{U}^{-1}$ and $\boldsymbol{V}^\text{T}=\boldsymbol{V}^{-1}$; see 2.6 for more details about orthogonal matrices)

- $\boldsymbol{D}$ being a diagonal matrix (all 0 except the diagonal). However $\boldsymbol{D}$ is not necessarily square.

<img src="images/singularValues.png" width=300 heigth=300>

The columns of $\boldsymbol{U}$ are the left-singular vectors of $\boldsymbol{A}$ while the columns of $\boldsymbol{V}$ are the right-singular vectors of $\boldsymbol{A}$. The values along the diagonal of $\boldsymbol{D}$ are the singular values of $\boldsymbol{A}$.

## How to do the singular values decomposition

The matrices $\boldsymbol{U}$, $\boldsymbol{D}$ and $\boldsymbol{V}$ can be found by transforming $\boldsymbol{A}$ in a square matrix and by computing the eigenvectors of this square matrix. The square matrix can be obtain by multiplying the matrix $\boldsymbol{A}$ by its transpose in one way or the other:

- $\boldsymbol{U}$ corresponds to the eigenvectors of $\boldsymbol{AA}^\text{T}$
- $\boldsymbol{V}$ corresponds to the eigenvectors of $\boldsymbol{A^\text{T}A}$
- $\boldsymbol{D}$ corresponds to the eigenvalues $\boldsymbol{AA}^\text{T}$ or $\boldsymbol{A^\text{T}A}$ which are the same.

Let's take an example of a non square matrix:

$
A=\begin{bmatrix}
    7 & 2\\\\
    3 & 4\\\\
    5 & 3
\end{bmatrix}
$

The singular value decomposition can be done with the `linalg.svd` function from Numpy. Note that `np.linalg.eig(A)` works only on square matrices and will give an error for `A`:


```python
A = np.array([[7, 2], [3, 4], [5, 3]])
print 'A:\n', A
print 'np.linalg.eig(A):', np.linalg.eig(A)
```

    A:
    [[7 2]
     [3 4]
     [5 3]]
    np.linalg.eig(A):


    ---------------------------------------------------------------------------

    LinAlgError                               Traceback (most recent call last)

    <ipython-input-4-54381188e09c> in <module>()
          1 A = np.array([[7, 2], [3, 4], [5, 3]])
          2 print 'A:\n', A
    ----> 3 print 'np.linalg.eig(A):', np.linalg.eig(A)
    

    /Users/lsp/.virtualenvs/kaggle/lib/python2.7/site-packages/numpy/linalg/linalg.pyc in eig(a)
       1125     a, wrap = _makearray(a)
       1126     _assertRankAtLeast2(a)
    -> 1127     _assertNdSquareness(a)
       1128     _assertFinite(a)
       1129     t, result_t = _commonType(a)


    /Users/lsp/.virtualenvs/kaggle/lib/python2.7/site-packages/numpy/linalg/linalg.pyc in _assertNdSquareness(*arrays)
        210     for a in arrays:
        211         if max(a.shape[-2:]) != min(a.shape[-2:]):
    --> 212             raise LinAlgError('Last 2 dimensions of the array must be square')
        213 
        214 def _assertFinite(*arrays):


    LinAlgError: Last 2 dimensions of the array must be square


## The left-singular values

The left-singular values of $\boldsymbol{A}$ correspond to the eigenvectors of $\boldsymbol{AA}^\text{T}$.

### Example 1.

Note that the sign difference comes from the fact that eigenvectors are not unique. The `linalg` functions from Numpy return the normalized eigenvectors. Scaling by `-1` doesn't change their direction or the fact that they are unit vectors.


```python
U, S, V = np.linalg.svd(A)
D = np.diag(S)
print '\nLeft singular vectors of A:\n', U

print '\nEigenvectors of AA_transpose:\n', np.linalg.eig(A.dot(A.T))[1]
```

## The right-singular values

The right-singular values of $\boldsymbol{A}$ correspond to the eigenvectors of $\boldsymbol{A}^\text{T}\boldsymbol{A}$.

### Example 2.


```python
U, S, V = np.linalg.svd(A)
print '\nRight singular vectors of A:\n', V

print '\nEigenvectors of A_transposeA:\n', np.linalg.eig(A.T.dot(A))[1]
```

## The nonzero singular values

The nonzero singular values of $\boldsymbol{A}$ are the square roots of the eigenvalues of $\boldsymbol{A}^\text{T}\boldsymbol{A}$ and $\boldsymbol{AA}^\text{T}$.

### Example 3.


```python
U, S, V = np.linalg.svd(A)
print '\nSingular values of A:\n', S

print '\nEigenvalues of A_transposeA:\n', np.linalg.eig(A.T.dot(A))[0]
print '\nEigenvalues of AA_transpose:\n', np.linalg.eig(A.dot(A.T))[0]
print '\nSquare root of the eigenvalues:\n', np.sqrt(np.linalg.eig(A.T.dot(A))[0])
```


```python
Proofs : https://www2.math.ethz.ch/education/bachelor/lectures/hs2014/other/linalg_INFK/svdneu.pdf
```

# References

[1] [C.O.S. Sorzano from Universidad San Pablo](http://biocomp.cnb.csic.es/~coss/Docencia/algebra/tema8.pdf)


```python
A
```


```python
plt.scatter(A[:,0], A[:,1])
plt.plot(V[0,:])
```


```python
x = np.linspace(-5, 5, 100000)
y = 2*np.sqrt(1-((x/3)**2))
plt.plot(x, y, 'b')
plt.plot(x, -y, 'b')
plt.xlim(-4, 4)
plt.ylim(-4, 4)
```

    /Users/lsp/.virtualenvs/kaggle/lib/python2.7/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in sqrt
      





    (-4, 4)




![png](../../assets/images/output_17_2.png)



```python
A = np.array([[3, 0], [0, 2]])
np.linalg.eig(A.dot(A.T))
```




    (array([ 9.,  4.]), array([[ 1.,  0.],
            [ 0.,  1.]]))




```python

```
